# 浏览器相关

作为前端开发人员，我们总是沉迷于各种前端框架，对于浏览器，我们大部分时候只是作为一个“测试工具”，我认为，浏览器的相关知识能够帮助我们更好的去开发，去了解到浏览器的原理，能让我们更好的去做优化和测试。

首先看一下浏览器的工作流程：

1. 浏览器使用 HTTP（s）协议向服务端请求页面
2. 将 HTML 解析，构造成 DOM 树
3. 计算 DOM 树上的 CSS 属性
4. 根据 CSS 对元素进行渲染，得到内存中的位图
5. 可选步骤：对位图进行渲染（极大增加后续渲染速度）
6. 绘制到界面上

## 解析 HTML 代码

要解析 HTML 代码，少不了计算机编译原理的知识，当浏览器拿到 HTTP 的Response 的 body 部分后，便开始处理。

### 1. 词的拆分

HTML 会被拆分成 token，也就是词，这一步叫**词法分析**，一段简单的代码来查看这一过程。

```html
<p class="text">This is a text.</p>
```

这段代码可以解析成以下几个部分：

- <p：标签的开始
- class="text"：属性
- \>: 标签开始的结束
- This is a text.：文本
- <\/p>：标签的结束

这些 token 是如何判断的呢，怎么知道 "<" 就是一个开始符号，而不是其他。将字符流转化为 token，这就需要由状态机来实现的。

### 2. 状态机

大部分语言的词法分析都是由状态机来实现，[HTML官方文档](https://html.spec.whatwg.org/multipage/parsing.html#tokenization)中规定了80个状态（对大部分语言来说，状态机是一种实现而非定义，而html有相关的定义文档）。

用状态机做词法分析，其实是把每个词的”特征字符“逐个拆分成独立状态，再合并起来，形成一个连通图结构

 
## 构建 DOM 树

将字符流转化为 token 后，下一步就是将简单的构建成 DOM 树，这个过程使用栈来实现，这一步涉及到的是语法分析，根据一些编译原理中常见的技巧，我们使用的栈正是用于匹配开始和结束标签的方案。

标签的开始和标签的结束需要成对比配。对于 Text 节点，我们则需要把相邻的 Text 节点合并起来，我们的做法是当词（token）入栈时，检查栈顶是否是 Text 节点，如果是的话就合并 Text 节点

通过栈，可以这样构建一个 DOM 树

- 栈顶元素就是当前节点
- 遇到属性就添加到当前节点
- 遇到文本节点，如果当前节点是文本节点，则合并，否则入栈成为当前节点的子节点
- 遇到注释节点，成为当前节点的子节点
- 遇到 tag start 就入栈一个节点，当前节点就是这个节点的父节点
- 遇到 tag end 就出栈一个节点

在构建 DOM 树的过程中，依次拿到构造好的元素，去检查元素匹配到哪些规则，根据规则的优先级，做调整，我们常说的选择器，应该被称为”匹配器“更为合适。

CSS同样需要经过词法分析和语法分析，解析成CSSOM树。

## 排版

当计算好 CSS 属性后，浏览器需要确定每个元素的位置，这个过程叫做排版。浏览器最基本的排版方案是**正常流排版**。而文字的排版有一套文字排版规范，文字排版是一个复杂的系统，它规定了行模型和文字在行模型中的排布。

元素和文字可以混合排版，元素被定义为占据长方形的区域，还允许边框、边距和留白，这个就是所谓的盒模型。

在正常流的基础上，浏览器支持两类特殊元素：绝对定位和浮动元素，除了正常流，浏览器还支持其他的排版方式，如 flex 布局，这些排版方式由外部元素 display 来控制。

## 渲染

这一步是根据元素的样式和大小信息，为每个元素在内存中渲染他的图形，并绘制到相应的位置。在图形学的意义中，就是把模型变成位图的过程。

这里的位图就是在内存中建立一张二维表格，把一张图片的每个像素的颜色保存进去。浏览器中渲染这个过程，就是把每一个元素对应的盒变成位图，一个元素可能对应多个盒（比如 inline 元素，可能会分成多行）。每一个盒对应着一张位图。

渲染的过程可以分为两个大类：图形和文字

盒的背景，边框，SVG元素，阴影等都是需要绘制的图形，每个系统都会有个底层库来支持。盒中的文字，也需要底层库来支持，叫做字体库。字形分为像素字形和矢量字形。

在普遍情况下，渲染过程生成的位图尺寸跟上一步排版时占据的尺寸相同，但是很多属性会影响到位图的大小。

> 渲染过程，是不会把子元素绘制到渲染的位图上的，这样，当父子元素的相对位置发生变化时，可以保证渲染的结果能够最大程度被缓存，减少重新渲染

## 合成

在渲染过程中该不会将子元素渲染到位图上，合成的过程，就是为一些元素创建一个“合成后的位图”，把一部分子元素渲染到合成的位图上。合成的目标是提高性能，而那些元素要创建合成后的位图，哪些元素渲染到合成的位图上是要考虑的策略。假如全部用位图来合成，一旦某个元素改变了 CSS 属性，合成后的位图就失效了，需要重新绘制。而假如全部元素不合成，结构就是每次都要重新绘制所有的元素。

好的合成策略就是猜测，猜测到可能会变化的元素，我们不让他合成。

```html
<div id="a">
  <div id="b">...</div>
  <div id="c" style="transform:translate(0,0)"></div>
</div>
```

假设以上的 html 结构，我们执行这样一段代码

```js
document.getElementById("c").style.transform = "translate(100px, 0)";
```

（假设 b 比较复杂）当我们采用这样的合成策略：把 a、b 两个元素合成，不合成 c，这样当我们每次只需要绘制 a 和 b 合成好的位图加上 c。从而减少绘制次数。

> 新的 CSS 标准中，规定了 will-change 属性，可以由业务代码来提示浏览器采用怎样的合成策略。

## 绘制

绘制一般是浏览器把需要显示的位图交给操作系统就可以了。一般最终显示的位图位于显存中。绘制过程就是按照 z-index 依次绘制到屏幕上，而实际中不会这么操作，因为“绘制“频率很高，每次鼠标滑动都造成绘制。

这个时候就需要限制绘制的面积，计算机图形学中使用的方案是“脏矩形”算法，均匀的将屏幕分成若干份，这样绘制的时候只需要重新绘制影响到的几个矩形区域就够了。